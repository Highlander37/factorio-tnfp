-- tnp_handle_gui_check()
--   Handles a gui checkbox/radiobutton being selected
function tnp_handle_gui_check(event)
    local player = game.players[event.player_index]

    if not player.valid then
        return
    end

    if event.element.name == "tnp-stationlist-stationtypetnfp" or event.element.name == "tnp-stationlist-stationtypetrain" or event.element.name == "tnp-stationlist-stationtypeall" then
        tnp_gui_stationlist_switch(player, event.element)
    end
end

-- tnp_handle_gui_click()
--   Handles a gui click
function tnp_handle_gui_click(event)
    local player = game.players[event.player_index]

    if not player.valid then
        return
    end

    if event.element.name == "tnp-stationlist-headingbuttonclose" then
        tnp_action_stationselect_cancel(player)
    elseif string.find(event.element.name, "tnp-stationlist-dest", 1, true) ~= nil then
        tnp_action_stationselect_redispatch(player, event.element)
    end
end

-- tnp_handle_input()
--   Handles a request via the custom input
function tnp_handle_input(event)
    tnp_handle_request(event, false)
end

-- tnp_handle_request()
--   Handles a request for a TNfP Train via input
function tnp_handle_request(event, shortcut)
    local player = game.players[event.player_index]

    if not player.valid then
        return
    end

    if not player.surface then
        tnp_message(tnpdefines.loglevel.core, player, {"tnp_error_location_surface", player.name})
        return
    end

    if not player.position then
        tnp_message(tnpdefines.loglevel.core, player, {"tnp_error_location_position", player.name})
        return
    end

    -- Determine whether we're already handling a request
    local train = tnp_state_player_get(player, 'train')
    if train then
        if not train.valid then
            -- We'd normally send a message, but because the trains invalid it'll be autogenerated from the prune task.
            tnp_action_request_cancel(player, train, nil)
            return
        end

        if shortcut then
            tnp_train_enact(train, true, nil, nil, false)
            tnp_action_request_cancel(player, train, {"tnp_train_cancelled"})
            return
        end

        --- !!!: TODO
        tnp_action_request_status(player, train)
    else
        -- We're not handling a request.

        -- The player is already on a train though.
        if player.vehicle and player.vehicle.train then
            local train = player.vehicle.train

            if tnp_train_check(player, train) then
                local status = tnp_state_train_get(train, 'status')
                local train_player = tnp_state_train_get(train, 'player')

                if train_player and (not train_player.valid or train_player.index ~= player.index) then
                    -- Special case where the train the players on now was assigned to another player.  This player wins.
                    tnp_train_enact(train, true, nil, false, nil)
                    tnp_action_request_cancel(train_player, train, {"tnp_train_cancelled_stolen", player.name})
                elseif status and status == tnpdefines.train.status.rearrived then
                    -- Another special case where the train has already been redispatched and we're waiting for the
                    -- player to disembark.  We need to reset the schedule before we reassign.
                    tnp_train_enact(train, true, nil, false, nil)
                end

                tnp_action_train_assign(player, nil, train)
                tnp_action_request_board(player, train)
                player.set_shortcut_toggled('tnp-handle-request', true)
            else
                -- The player is on a non-tnp train.
                tnp_message(tnpdefines.loglevel.standard, player, {"tnp_train_nontnp"})
            end
        else
            tnp_action_request_create(player)
            player.set_shortcut_toggled('tnp-handle-request', true)
        end
    end
end

-- tnp_handle_shortcut()
--   Handles a shortcut being pressed
function tnp_handle_shortcut(event)
    if event.prototype_name == "tnp-handle-request" then
        tnp_handle_request(event, true)
    end
end

-- tnp_handle_tick_prune()
--   Triggers a period prune of invalid data
function tnp_handle_tick_prune(event)
    _tnp_state_gui_prune()
    _tnp_state_player_prune()
    _tnp_state_train_prune()
end

-- tnp_handle_tick_timeout()
--   Handle a per-second event to timeout train deliveries
function tnp_handle_tick_timeout(event)
    tnp_action_timeout()
end

-- tnp_handle_player_vehicle()
--   Handles a player entering or exiting a vehicle
function tnp_handle_player_vehicle(event)
    local player = game.players[event.player_index]

    if not player.valid then
        return
    end

    -- This player doesnt have a request outstanding
    if not tnp_state_player_query(player) then
        -- Check whether they've stolen a tnp assigned train
        if event.entity and event.entity.train and tnp_state_train_query(event.entity.train) then
            local train = event.entity.train
            local train_player = tnp_state_train_get(train, 'player')

            if train_player and (not train_player.valid or train_player.index ~= player.index) then
                tnp_train_enact(train, true, nil, nil, nil)
                tnp_action_request_cancel(train_player, train, {"tnp_train_cancelled_stolen", player.name})
            end
        end

        return
    end

    if player.vehicle then
        -- Dont track entering non-train vehicles
        if not player.vehicle.train then
            return
        end

        local train = tnp_state_player_get(player, 'train')
        if not train or not train.valid then
            -- The train we were tracking is now invalid, and will have a limbo schedule unfortunately.
            tnp_message(tnpdefines.loglevel.core, player, {"tnp_train_cancelled_invalid"})
            tnp_action_request_cancel(player, nil, nil)
        elseif train.id ~= event.entity.train.id then
            -- Player has boarded a different train.  Send the other train away (optional?)
            tnp_train_enact(train, true, nil, nil, nil)
            tnp_action_request_cancel(player, train, {"tnp_train_cancelled_wrongtrain"})
        else
            -- Player has successfully boarded their tnp train
            tnp_action_request_board(player, train)
        end
    else
        -- Player has exited a vehicle -- this could be anything.

        -- Are we actually tracking a train for this player?  If not dont do anything.
        local train = tnp_state_player_get(player, 'train')
        if train then
            -- Attempt to close the stationlist regardless, just in case the players exited the train we sent
            tnp_gui_stationlist_close(player)

            -- We were tracking a train, but its no longer valid
            if not train.valid then
                tnp_action_request_cancel(player, train, nil)
                return
            end

            local status = tnp_state_train_get(train, 'status')

            -- It shouldn't be possible to exit a vehicle in a dispatching/dispatched status, as entering the vehicle
            -- would have triggered the boarding event.  We dont need to handle redispatched, as thats done via station
            -- wait conditions.
            if status == tnpdefines.train.status.arrived then
                tnp_train_enact(train, true, nil, nil, nil)
                tnp_action_request_cancel(player, train, {"tnp_train_cancelled"})
            elseif status == tnpdefines.train.status.redispatched then
                tnp_train_enact(train, true, nil, nil, nil)
                tnp_action_request_cancel(player, train, {"tnp_train_complete"})
            end
        end
    end
end


-- tnp_handle_train_schedulechange()
--   Handles a trains schedule being changed
function tnp_handle_train_schedulechange(event)
    -- A train we're not tracking
    if not tnp_state_train_query(event.train) then
        return
    end

    local player = nil
    if event.player_index and game.players[event.player_index] then
        player = game.players[event.player_index]
    end

    tnp_action_train_schedulechange(event.train, player)
end

-- tnp_handle_train_statechange()
--   Handles a trains state being changed
function tnp_handle_train_statechange(event)
    if not event.train.valid then
        return
    end

    -- A train we're not tracking
    if not tnp_state_train_query(event.train) then
        return
    end

    tnp_action_train_statechange(event.train)
end